
@{
    ViewData["Title"] = "Using UDAs for customisation";
    ViewData["NavItem"] = "Blog";
}

<section class="bluer background">
    <div class="one column grid">
        <div class="row">
            <div class="center column">
                <article class="blog post">
                    <h1>Creating a simple JSON serialiser in D #5 - Using UDAs for customisation</h1>
                    <p>
                        <em>
                            This post is a follow up of
                            <a asp-action="Blog" asp-route-post="JsonSerialiser4">Serialising arrays</a>.
                        </em>
                    </p>
                    <p>
                        At the moment, our serialiser is still really basic and rigid, without really any way to customise
                        how it serialises/deserialises our data.
                    </p>
                    <p>
                        So the topic for this post is to explore using <a href="https://dlang.org/spec/attribute.html#uda">UDAs</a> 
                        (User Defined Attributes) to allow a clean way of customising the functionality of our serialiser.
                    </p>

                    <h2>Basic usage of UDAs</h2>
                    <p>
                        A UDA in D can be pretty much anything, such as a struct, any primitive type, you can
                        even use functions that are executed at compile-time which return a value to be used as a UDA.
                    </p>
                    <p>
                        To attach a UDA onto something, you use the form <code>@@TypeName</code>, e.g:
                        <pre><code>
// <a href="https://godbolt.org/z/69d7am">https://godbolt.org/z/69d7am</a>
enum AnEnum{a}
struct AStruct{}
class AClass{}

int FunctionThatReturnsTheUDAValue(){ return 0; }

@@AnEnum
@@AStruct
@@AClass
@@FunctionThatReturnsTheUDAValue
struct Test{}

void main()
{
    import std.traits;

    // <a href="https://dlang.org/spec/traits.html#getAttributes">__traits(getAttributes)</a> is another special __trait
    // which returns a tuple of all UDAs on a symbol.
    static foreach(uda; __traits(getAttributes, Test))
        pragma(msg, uda);

    /* Output:
        AnEnum
        AStruct
        AClass
        0
    */
}
                        </code></pre>
                    </p>

                    <h3>How to access a UDA on a symbol</h3>
                    <p>
                        There are a few ways to do this. One way that the above example shows is to use
                        the <a href="https://dlang.org/spec/traits.html#getAttributes">__traits(getAttributes)</a> function
                        to get a tuple of every UDA on a symbol.
                    </p>
                    <p>
                        While <code>__traits(getAttributes)</code> is the most flexible way to mess with UDAs, and
                        is how the next few templates below are able to function in the first place, it can be a bit
                        too much of a hassle to work with when all you want to do are simple checks such as "Is this struct marked
                        <code>@@Special</code>", or "Get me ONLY the <code>@@Special</code> UDA from this struct".
                    </p>
                    <p>
                        Here enters <a href="https://dlang.org/phobos/std_traits.html#hasUDA">std.traits.hasUDA</a>
                        and <a href="https://dlang.org/phobos/std_traits.html#getUDAs">std.traits.getUDAs</a>.
                        Special mention to <a href="https://dlang.org/phobos/std_traits.html#getSymbolsByUDA">std.traits.getSymbolsByUDA</a>
                        as I won't be using it in this post, but it's still very useful. I feel a quick example should be enough of
                        a demonstration of their usage:
                    </p>
                    <pre><code>
// <a href="https://godbolt.org/z/Tszj-k">https://godbolt.org/z/Tszj-k</a>
struct UsefulUDA
{
    string some;
    int data;
}

struct NeverUsedUDA
{
}

struct MultiUDA
{
    string data;
}

@@UsefulUDA("Foo", 21)
@@MultiUDA("Use")
@@MultiUDA("Me")
@@(MultiUDA("Multiple"), MultiUDA("Times"))
struct MyStruct
{

}

void main()
{
    import std.traits : hasUDA, getUDAs;
    import std.stdio  : writeln, write;

    writeln("Does struct have @@UsefulUDA: ", hasUDA!(MyStruct, UsefulUDA));
    writeln("What about @@NeverUsedUDA:    ", hasUDA!(MyStruct, NeverUsedUDA));

    // Since UDAs can be used multiple times, getUDAs will return a tuple of ALL
    // UDAs that you ask it for.
    // So if you only want a single one, you'll have to get the [0]th one.
    const UsefulUDA useful = getUDAs!(MyStruct, UsefulUDA)[0];
    writeln(useful);

    // And of course, you can iterate over the results for UDAs that occur multiple times.
    static foreach(uda; getUDAs!(MyStruct, MultiUDA))
        write(uda.data, " ");

    /* Output:  
        Does struct have @@UsefulUDA: true
        What about @@NeverUsedUDA:    false
        const(UsefulUDA)("Foo", 21)
        Use Me Multiple Times 
    */
}
                    </code></pre>
                    <p>
                        Using this newly learned magic, we'll be upgrading our serialiser with the following three UDAs:
                    </p>
                    <ul>
                        <li>
                            <code>@@Ignore</code> - Completely ignore a field.
                        </li>
                        <li>
                            <code>@@Name</code> - Set a custom name to serialise a field as.
                        </li>
                        <li>
                            <code>@@ByValue</code> - Serialise an enum by value, rather than by name.
                        </li>
                    </ul>

                    <h2>Creating the UDAs, and a struct to test with</h2>
                    <p>
                        All of our UDAs will be <code>structs</code>, as that's just how I roll with UDAs.
                    </p>
                    <p>
                        We will also need a struct to test our UDAs with, so we're going to create a copy of our
                        <code>Person</code> struct, and give each field a UDA:
                    </p>
                    <pre><code>
struct ByValue {}
struct Ignore {}

struct Name
{
    string name;
}

// Keep this version of `Person` around, as I'll use it to compare the output between
// using UDAs, and not using them.
struct Person
{
    string name;
    int age;
    PersonType type;
}

struct PersonWithUDAs
{
    @@Ignore
    string name;

    @@Name("yearsOld")
    int age;

    @@ByValue
    PersonType type;
}
                    </code></pre>

                    <h2>Implementing the @@Ignore UDA</h2>
                    <h3>Serialise support</h3>
                    <p>
                        Reference of the current <code>serialise</code> function:
                    </p>
                    <pre><code>
JSONValue serialise(T)(T value)
{    
    /* omitted for brevity */
    else static if(is(T == struct) || is(T == class))
    {
        JSONValue toReturn;

        static if(is(T == class))
        { /**/ }

        static foreach(member; T.tupleof)
        {{
            alias MemberType = typeof(member);
            const MemberName = __traits(identifier, member);

            MemberType memberValue = mixin("value." ~ MemberName);
            toReturn[MemberName] = serialise(memberValue);
        }}

        return toReturn;
    }
    /**/
}    
                    </code></pre>
                    <p>
                        Your first thought for implementing <code>@@Ignore</code> might be to use
                        <code>continue</code> if the field has the UDA attached to it.
                    </p>
                    <p>
                        However, <code>static foreach</code> and <code>continue</code> don't exactly
                        work well together, or really at all (think about how <code>static foreach</code> works,
                        specifically that it unrolls itself to generate code).
                    </p>
                    <p>
                        So, we're going to have to be a bit more creative. Basically, we'll lock the last
                        line of the <code>static foreach</code> (which performs the actual serialisation)
                        behind a <code>static if</code> that checks whether the field is to be ignored or not:
                    </p>
                    <pre><code>
JSONValue serialise(T)(T value)
{    
    /* omitted for brevity */
    else static if(is(T == struct) || is(T == class))
    {
        JSONValue toReturn;

        static if(is(T == class))
        { /**/ }

        static foreach(member; T.tupleof)
        {{
            alias MemberType = typeof(member);
            const MemberName = __traits(identifier, member);

            MemberType memberValue = mixin("value." ~ MemberName);

            // An annoying thing to have to do, but worth the gains that static foreach brings us.
            static if(!hasUDA!(member, Ignore))
            {
                toReturn[MemberName] = serialise(memberValue);
            }
        }}

        return toReturn;
    }
    /**/
}
                    </code></pre>
                    <p>
                        It's a bit of an iffy way to go about things compared to simply being able to <code>continue</code>
                        like in a normal loop, but it does the job.
                    </p>

                    <h3>Deserialise support</h3>
                    <p>
                        Reference of the current <code>deserialise</code> function:
                    </p>
                    <pre><code>
T deserialise(T)(JSONValue json)
{    
    /**/
    else static if(is(T == struct) || is(T == class))
    {
        static if(is(T == class))
        {
            /**/

            static if(HasDefaultCtor!T)
            {
                T toReturn = new T();
            }
        }
        else
        {
            T toReturn;
        }

        static if(HasStaticDeserialiseFunc!T)
        { /**/ }
        else
        {
            static foreach(member; T.tupleof)
            {{
                alias MemberType = typeof(member);
                const MemberName = __traits(identifier, member);

                MemberType memberValue = deserialise!MemberType(toReturn[MemberName]);

                mixin("toReturn." ~ MemberName ~ " = memberValue;");
            }}

            return toReturn;
        }
    }
    /**/
}
                    </code></pre>
                    <p>
                        This is pretty much the same deal: lock the code that does the actual deserialisation behind
                        a <code>static if</code> that checks for the <code>@@Ignore</code> UDA:
                    </p>
                    <pre><code>
T deserialise(T)(JSONValue json)
{    
    /**/
    else static if(is(T == struct) || is(T == class))
    {
        /**/
        else
        {
            static foreach(member; T.tupleof)
            {{
                alias MemberType = typeof(member);
                const MemberName = __traits(identifier, member);

                static if(!hasUDA!(member, Ignore))
                {
                    MemberType memberValue = deserialise!MemberType(json[MemberName]);

                    mixin("toReturn." ~ MemberName ~ " = memberValue;");
                }
            }}

            return toReturn;
        }
    }
    /**/
}
                    </code></pre>

                    <h3>Test</h3>
                    <p>
                        While testing the UDAs, the tests will show the output from both <code>Person</code> and
                        <code>PersonWithUDAs</code> to make the differences more obvious.
                    </p>
                    <pre><code>
// <a href="https://godbolt.org/z/VYWCjw">https://godbolt.org/z/VYWCjw</a>
void main()
{
    import std.stdio : writeln;
    
    auto person     = Person("Bradley", 20, PersonType.Student);
    auto personUDA  = PersonWithUDAs("Bradley", 20, PersonType.Student);
    writeln(person.serialise());
    writeln(personUDA.serialise());

    writeln(person.serialise().deserialise!Person());
    writeln(personUDA.serialise().deserialise!PersonWithUDAs());

    /* Output:
        {"age":20,"name":"Bradley","type":"Student"}
        {"age":20,"type":"Student"}
        Person("Bradley", 20, Student)
        PersonWithUDAs("", 20, Student)
    */
}
                    </code></pre>
                    <p>
                        As you can see, in the JSON output for <code>PersonWithUDAs</code>, the "name"
                        field is completely missing, and when we serialise it back into a struct the "name"
                        field is left as <code>string.init</code>, since we never give it a value.
                    </p>

                    <h2>Implementing the @@Name UDA</h2>
                    <h3>Serialise support</h3>
                    <p>
                        Adding support in the <code>serialise</code> function isn't anything too
                        difficult. If the field has <code>@@Name</code> attached to it then
                        we use the string given by that UDA as the value's key, instead of
                        the field's name.
                    </p>
                    <p>
                        We will also store the serialised value in it's own variable in preparation
                        for the next UDA:
                    </p>
                    <pre><code>
JSONValue serialise(T)(T value)
{    
    /* omitted for brevity */
    else static if(is(T == struct) || is(T == class))
    {
        JSONValue toReturn;

        static if(is(T == class))
        { /**/ }

        static foreach(member; T.tupleof)
        {{
            alias MemberType = typeof(member);
            const MemberName = __traits(identifier, member);

            MemberType memberValue = mixin("value." ~ MemberName);

            static if(!hasUDA!(member, Ignore))
            {
                JSONValue serialised = serialise(memberValue);

                static if(hasUDA!(member, Name)) // Use custom name if needed.
                {
                    const SerialiseName = getUDAs!(member, Name)[0].name;
                    toReturn[SerialiseName] = serialised;
                }
                else // Otherwise just use the field's name.
                {
                    toReturn[MemberName] = serialised;
                }
            }
        }}

        return toReturn;
    }
    /**/
}
                    </code></pre>

                    <h3>Deserialise support</h3>
                    <p>
                        Again, not too difficult, we will store the value to deserialise in its own variable and use
                        <code>static if</code> to determine whether to use the field's actual name, or
                        whatever name was provided by <code>@@Name</code>.
                    </p>
                    <pre><code>
T deserialise(T)(JSONValue json)
{    
    /**/
    else static if(is(T == struct) || is(T == class))
    {
        /**/
        else
        {
            static foreach(member; T.tupleof)
            {{
                alias MemberType = typeof(member);
                const MemberName = __traits(identifier, member);

                static if(!hasUDA!(member, Ignore))
                {
                    static if(hasUDA!(member, Name))
                    {
                        const SerialiseName = getUDAs!(member, Name)[0].name; 
                        JSONValue value = json[SerialiseName];
                    }
                    else
                    {
                        JSONValue value = json[MemberName];
                    }

                    MemberType memberValue = deserialise!MemberType(value);

                    mixin("toReturn." ~ MemberName ~ " = memberValue;");
                }
            }}

            return toReturn;
        }
    }
    /**/
}    
                    </code></pre>

                    <h3>Test</h3>
                    <p>
                        The testing code is the same as before, but now that we've implemented support for
                        <code>@@Name</code>, the output is a bit different:
                    </p>
                    <pre><code>
// <a href="https://godbolt.org/z/_n6fbB">https://godbolt.org/z/_n6fbB</a>   
void main()
{
    import std.stdio : writeln;
    
    auto person     = Person("Bradley", 20, PersonType.Student);
    auto personUDA  = PersonWithUDAs("Bradley", 20, PersonType.Student);
    writeln(person.serialise());
    writeln(personUDA.serialise());

    writeln(person.serialise().deserialise!Person());
    writeln(personUDA.serialise().deserialise!PersonWithUDAs());

    /* Output:
        {"age":20,"name":"Bradley","type":"Student"}
        {"type":"Student","yearsOld":20}
        Person("Bradley", 20, Student)
        PersonWithUDAs("", 20, Student)
    */
}
                    </code></pre>
                    <p>
                        As you can see, the JSON output for <code>PersonWithUDAs</code> now uses
                        "yearsOld" instead of "age" to store the person's age.
                    </p>

                    <h2>Implementing the @@ByValue UDA</h2>
                    <h3>Serialise support</h3>
                    <p>
                        For serialisation, we need to add a <code>static if</code> that checks for the
                        <code>@@ByValue</code> UDA (and for good measure, making sure it's an enum), and
                        then pass the value directly to the constructor of <code>JSONValue</code> to serialise its value:
                    </p>
                    <pre><code>
JSONValue serialise(T)(T value)
{    
    /* omitted for brevity */
    else static if(is(T == struct) || is(T == class))
    {
        /**/
        static foreach(member; T.tupleof)
        {{
            alias MemberType = typeof(member);
            const MemberName = __traits(identifier, member);

            MemberType memberValue = mixin("value." ~ MemberName);

            static if(!hasUDA!(member, Ignore))
            {
                static if(hasUDA!(member, ByValue) && is(MemberType == enum))
                {
                    JSONValue serialised = JSONValue(memberValue);
                }
                else
                {
                    JSONValue serialised = serialise(memberValue);
                }

                static if(hasUDA!(member, Name))
                {
                    const SerialiseName = getUDAs!(member, Name)[0].name;
                    toReturn[SerialiseName] = serialised;
                }
                else
                {
                    toReturn[MemberName] = serialised;
                }
            }
        }}
        /**/
    }
    /**/
}  
                    </code></pre>

                    <h3>Deserialise support</h3>
                    <p>
                        To finish off with our last UDA, we need to employ <code>static if</code>
                        yet again to check for <code>@@ByValue</code>, and if the field has the UDA
                        then instead of recursively calling the <code>deserialise</code> function we will
                        instead directly convert the JSONValue into the field's type via the wonderful
                        <code>std.conv.to</code> function.
                    </p>
                    <p>
                        Not only can it convert by name, it can also convert by value!
                    </p>
                    <p>
                        I'd like to note that in D, an enum's base type isn't limited to just numeric types
                        such as <code>int</code> or <code>uint</code>, but to keep things simple we'll just assume that the enum's
                        base type is <code>int</code>.
                    </p>
                    <pre><code>
T deserialise(T)(JSONValue json)
{    
    /**/
    else static if(is(T == struct) || is(T == class))
    {
        /**/
        else
        {
            static foreach(member; T.tupleof)
            {{
                alias MemberType = typeof(member);
                const MemberName = __traits(identifier, member);

                static if(!hasUDA!(member, Ignore))
                {
                    static if(hasUDA!(member, Name))
                    {
                        const SerialiseName = getUDAs!(member, Name)[0].name; 
                        JSONValue value = json[SerialiseName];
                    }
                    else
                    {
                        JSONValue value = json[MemberName];
                    }

                    // We can't use `deserialise` again, as that assumes enums are stored by name, as strings.
                    // So we have to go this route.
                    static if(hasUDA!(member, ByValue))
                    {
                        MemberType memberValue = value.integer.to!MemberType();
                    }
                    else
                    {
                        MemberType memberValue = deserialise!MemberType(value);
                    }

                    mixin("toReturn." ~ MemberName ~ " = memberValue;");
                }
            }}

            return toReturn;
        }
    }
    /**/
}    
                    </code></pre>

                    <h3>Test</h3>
                    <p>
                        Just like with <code>@@Name</code>, we're using the same testing code as before, but
                        now that we've implemented <code>@@ByValue</code> we should get different results:
                    </p>
                    <pre><code>
// <a href="https://godbolt.org/z/TXLkMC">https://godbolt.org/z/TXLkMC</a>   
void main()
{
    import std.stdio : writeln;
    
    auto person     = Person("Bradley", 20, PersonType.Student);
    auto personUDA  = PersonWithUDAs("Bradley", 20, PersonType.Student);
    writeln(person.serialise());
    writeln(personUDA.serialise());

    writeln(person.serialise().deserialise!Person());
    writeln(personUDA.serialise().deserialise!PersonWithUDAs());

    /* Output:
        {"age":20,"name":"Bradley","type":"Student"}
        {"type":1,"yearsOld":20}
        Person("Bradley", 20, Student)
        PersonWithUDAs("", 20, Student)
    */
}
                    </code></pre>
                    <p>
                        And voila: the enum is now stored by its value instead of its name.
                    </p>

                    <h2>Conclusion</h2>
                    <p>
                        Via the power of UDAs, we can now customise to a basic extent the way our serialiser works.
                    </p>
                    <p>
                        One of the downsides of course is that our single-function <code>serialise</code> and
                        <code>deserialise</code> functions are becoming very unweidly and will continue to do so
                        as more and more UDAs are added (e.g. via the excercises below), so I encourage you to
                        experiment with <a asp-action="Blog" asp-route-post="JsonSerialiser1_1">a different way</a>
                        of organising these two functions, or just a better way to organise the entire project as a whole.
                    </p>
                    <p>
                        There will likely be a large gap in time between this post and the next (which may or may not be the last of
                        this series) as I will be improving certain aspects of the website now that I have a few posts to design around,
                        putting more time into other projects, etc.
                    </p>
                    <p>
                        In the meantime, I hope this series of posts have provided a decent enough introduction into the
                        myriad of metaprogramming features that D can provide you, such that you're able to recognise the sheer
                        power, productivity benefits, and also possibly the downsides that these features can gift you.
                    </p>
                    <p>
                        "With great power comes great responsibilty."
                    </p>
                    <p>
                        <a asp-action="Blog" asp-route-post="JsonSerialiser4">Previous post - Serialising arrays</a>
                    </p>
                    <p>
                        <a>Next post - Soon (tm)</a>
                    </p>

                    <h2>Excercises</h2>
                    <h3>Excercise #1 - Implement more UDAs</h3>
                    <p>
                        There won't be a test case for this one, as it completely depends on what UDAs you decide
                        to implement.
                    </p>
                    <p>
                        Here are a few ideas:
                    </p>
                    <ul>
                        <li>@@MaxLength and @@MinLength - Arrays must have at least/at most a certain length.</li>
                        <li>@@MatchesRegex - Strings must match the provided regex. 
                            (See also 
                                <a href="https://dlang.org/phobos/std_regex.html">std.regex</a>
                            )
                        </li>
                        <li>@@InRange - Numeric types must be within/outside/whatever a certain range.</li>
                        <li>@@Description - Serialisation will output a description for a field. A bit iffy when using JSON, but possible.</li>
                        <li>@@Names - A list of possible names that the value could be serialised/deserialised as.</li>
                        <li>@@CaseInsensitive - A value could be serialised as "KEY" or "kEy" and both would work.</li>
                    </ul>
                </article>
            </div>
        </div>
    </div>
</section>