
@{
    ViewData["Title"] = "Serialising enums and classes";
    ViewData["NavItem"] = "Blog";
}

<section class="bluer background">
    <div class="one column grid">
        <div class="row">
            <div class="center column">
                <article class="blog post">
                    <h1>Creating a simple JSON serialiser in D #3 - Serialising enums and classes</h1>
                    <p>
                        <em>
                            This post is a follow up of
                            <a asp-action="Blog" asp-route-post="JsonSerialiser2">Serialising structs</a>.
                        </em>
                    </p>
                    <p>
                        <em>
                            Side note: In true D fashion, run.dlang.org's ability to create snippets has been
                            broken for a few weeks, with no sign of it being fixed, so I've swapped over to a
                            difference service for the snippet links.
                        </em>
                    </p>
                    <p>
                        In this post, we'll be going over how to serialise classes and enums,
                        both of which have certain considerations to go over.
                    </p>

                    <h2>Serialising enums</h2>
                    <p>
                        The first thing to consider with enums is whether to serialise them via their names
                        (e.g. <code>PersonType.Student</code> would become "Student"), or to serialise them
                        via their values.
                    </p>
                    <p>
                        There are pros and cons to both, mostly revolving around enums that are used as bit flags,
                        but for now we're going to serialise them by names and later on provide a way to use either
                        names or values.
                    </p>
                    <p>
                        We're going to need an enum to work with, so let's create a <code>PersonType</code> enum
                        for our <code>Person</code> struct from our <a href="https://run.dlang.io/is/nCESzP">previous code</a>:

                        <pre><code>
enum PersonType
{
    Unknown,
    Student,
    Staff
}

struct Person
{
    string name;
    int age;
    PersonType type;
}
                        </code></pre>
                    </p>

                    <h3>The issue with enums</h3>
                    <p>
                        There is one fairly important, but easy to solve issue with enums - they count as both an enum,
                        as well as their value type.
                    </p>
                    <p>
                        For example take our newly made <code>PersonType</code> enum. It is just a
                        bog standard enum where the value type is an <code>int</code> (by default).
                    </p>
                    <p>
                        The <code>PersonType</code> enum, due to having a value type of <code>int</code>, will actually
                        <strong>pass</strong> a check such as <code>is(PersonType == int)</code> and <code>isNumeric!PersonType</code>.
                        Needless to say this is a bit of a roadblock due to our decision to serialise by name instead of value.
                    </p>
                    <p>
                        Fortunately, this issue is actually super easy to work around. Via <code>is(T == enum)</code> we can create
                        code that works/doesn't work specifically for enums.
                    </p>

                    <h3>Upgrading our serialise function</h3>
                    <p>
                        For reference, here's the shortened code for the serialise function:

                        <pre><code>
enum isPrimitiveType(T) = isNumeric!T || is(T == bool) || is(T == string);

JSONValue serialise(T)(T value)
{    
    static if(isPrimitiveType!T)
    { /* omitted for brevity */ }
    else static if(is(T == struct))
    { /* omitted for brevity */ }
    else
    { /* omitted for brevity */ }
}
                        </code></pre>
                    </p>
                    <p>
                        There are two options for us to take here:
                    </p>
                    <ul>
                        <li>Modify <code>isPrimitiveType</code> so that it ignore enums, then handle enums later on in the function.</li>
                        <li>Handle enums inside the function <strong>before</strong> handling primitive types, so enums get a larger 'priority'.</li>
                    </ul>
                    <p>
                        We will in fact be doing both - option #1 for the <code>serialise</code> function, and then option #2 for the
                        <code>deserialise</code> function.
                    </p>
                    <p>
                        So first off, by using <code>!is(T == enum)</code> we can make <code>isPrimitiveType</code> ignore enums:

                        <pre><code>
// <a href="https://godbolt.org/z/_edV5X">https://godbolt.org/z/_edV5X</a>
enum isPrimitiveType(T) = !is(T == enum) && (isNumeric!T || is(T == bool) || is(T == string));    
                        </code></pre>
                    </p>
                    <p>
                        Next we need to add a <code>static if</code> so we can handle enums, and then turn the enum
                        value into its name with the help of the ever-so-useful <code>std.conv.to</code> function:

                        <pre><code>
JSONValue serialise(T)(T value)
{    
    static if(isPrimitiveType!T)
    { /* omitted for brevity */ }
    else static if(is(T == enum))
    {
        return JSONValue(value.to!string()); // PersonType.Student -> "Student", PersonType.Staff -> "Staff", etc.
    }
    else static if(is(T == struct))
    { /* omitted for brevity */ }
    else
    { /* omitted for brevity */ }
}    
                        </code></pre>
                    </p>
                    <p>
                        Note that if you do something weird such as <code>cast(PersonType)400</code>, then
                        <code>std.conv.to</code> will actually return <code>"cast(PersonType)400"</code>, which
                        will cause errors down the line.
                    </p>

                    <h3>Upgrading our deserialise function</h3>
                    <p>
                        For reference, here's the shortened code for the deserialise function:

                        <pre><code>
T deserialise(T)(JSONValue json)
{
    static if(is(T == string))
    { /* omitted for brevity */ }
    else static if(is(T == bool))
    { /**/ }
    else static if(isFloatingPoint!T)
    { /**/ }   
    else static if(isSigned!T)
    { /**/ }
    else static if(isUnsigned!T)
    { /**/ }
    else static if(is(T == struct))
    { /**/ }
    else
    { /**/ }
}
                        </code></pre>
                    </p>
                    <p>
                        As I mentioned before, for the <code>deserialise</code> function we're going to handle
                        enums before any other type, so that the enum path takes priority over the others.
                    </p>
                    <p>
                        Yet again, the handy <code>std.conv.to</code> function comes to our rescue as it can convert a string into an enum,
                        as long as the string has the same name as one of the enum values:

                        <pre><code>
T deserialise(T)(JSONValue json)
{
    static if(is(T == enum))
    {
        // "Student" -> PersonType.Student, etc.
        return json.str.to!T();
    }
    else static if(is(T == string))
    { /* omitted for brevity */ }
    else static if(is(T == bool))
    { /**/ }
    else static if(isFloatingPoint!T)
    { /**/ }   
    else static if(isSigned!T)
    { /**/ }
    else static if(isUnsigned!T)
    { /**/ }
    else static if(is(T == struct))
    { /**/ }
    else
    { /**/ }
}     
                        </code></pre>
                    </p>
                    <p>
                        Finally, as usual, we'll give things a quick test:
                        <pre><code>
// <a href="https://godbolt.org/z/f4xTyB">https://godbolt.org/z/f4xTyB</a>
void main()
{
    import std.stdio : writeln;
    
    auto json = serialise(PersonType.Student);
    writeln(json);                          // "Student"
    writeln(json.deserialise!PersonType()); // Student
    
    json = serialise(Person("Bradley", 20, PersonType.Student));
    writeln(json);                      // {"age":20,"name":"Bradley","type":"Student"}
    writeln(json.deserialise!Person()); // Person("Bradley", 20, Student)
}
                        </code></pre>
                    </p>

                    <h2>Serialising classes</h2>
                    <p>
                        Serialising classes is where a lot of the more important decisions come into play, as
                        structs and classes are very different from one another.
                    </p>
                    <p>
                        For example, while we can just treat classes like they're structs, that will only support
                        a very tiny amount of classes, because:
                    </p>
                    <ul>
                        <li>Classes can be null.</li>
                        <li>Classes may not have a reliable way to construct them (more on that later in the post).</li>
                        <li>Classes tend to not expose variables directly, but via getters, setters, and other functions.</li>
                        <li>And many other reasons...</li>
                    </ul>
                    <p>
                        This post will provide a way to handle some of these issues, but in a real project you may
                        need to fine tune how the serialiser works for your own needs, as my solutions are going to be
                        relatively basic and therefore, not robust.
                    </p>

                    <h3>Treating classes as structs</h3>
                    <p>
                        Before we can start taking on some of the other issues, we need to treat the most
                        basic case of simply being able to serialise and deserialise a class' public variables,
                        and then build off of that.
                    </p>
                    <p>
                        For now, we'll assume that all classes passed to the serialise function are not-null.
                        So for serialisation, we can very simply just modify the <code>static if</code> that checks
                        for a struct, and extend it to also check for a class:

                        <pre><code>
JSONValue serialise(T)(T value)
{    
    static if(isPrimitiveType!T)
    { /* omitted for brevity */ }
    else static if(is(T == enum))
    { /**/ }
    else static if(is(T == struct) || is(T == class)) // &lt;-----
    { /**/ }
    else
    { /**/ }
}   
                        </code></pre>
                    </p>
                    <p>
                        This will work for extremely simple classes, e.g. if you were to change <code>Person</code>
                        to a class, it should be able to serialise a non-null instance of it perfectly fine.
                    </p>
                    <p>
                        For the deserialise function, our biggest hurdle is constructing a new instance of the class
                        so we can populate its fields. For now, our code will just assume that there is a default constructor
                        (e.g. <code>new MyClass()</code> works). Also keep in mind that <code>static if</code> does not
                        create a scope:

                        <pre><code>
T deserialise(T)(JSONValue json)
{
    static if(is(T == enum))
    { /* omitted for brevity */ }
    /**/
    else static if(is(T == struct) || is(T == class)) // Remember to check for a class here as well.
    {
        static if(is(T == class))
        {
            T toReturn = new T();
        }
        else
        {
            T toReturn; // Classes default to `null`, so we can't just reuse this line with them.
        }

        static foreach(member; T.tupleof)
        {{
            /**/
        }}

        return toReturn;
    }
    else
    { /**/ }
}
                        </code></pre>
                    </p>
                    <p>
                        As a quick example, change/copy <code>Person</code> to a class, and then we can
                        test if it works:

                        <pre><code>
// <a href="https://godbolt.org/z/EhHVdN">https://godbolt.org/z/EhHVdN</a>
void main()
{
    import std.stdio : writeln, writefln;

    // The compiler doesn't generate a helper constructor like with structs,
    // so we'll do things like this for now.
    auto p = new Person();
    p.name = "Bradley";
    p.age = 20;
    p.type = PersonType.Student;

    auto json = p.serialise();
    writeln(json); // {"age":20,"name":"Bradley","type":"Student"}

    // writeln can't automatically format a class like with structs.
    // So either override the `toString` function in a class, or just manually write out the fields.
    writefln("Person(%s, %s, %s)", p.name, p.age, p.type);

    // Output: Person(Bradley, 20, Student)
}
                        </code></pre>
                    </p>

                    <h3>Handling 'classes can be null'</h3>
                    <p>
                        Realistically, being able to handle null classes is a mandatory requirement, so
                        let's get that out of the way quickly.
                    </p>
                    <p>
                        For serialising, if the class is null, then we can return a <code>JSONValue(null)</code>
                        which works perfectly fine:

                        <pre><code>
JSONValue serialise(T)(T value)
{    
    static if(isPrimitiveType!T)
    { /* omitted for brevity */ }
    else static if(is(T == enum))
    { /**/ }
    else static if(is(T == struct) || is(T == class))
    {
        JSONValue toReturn;

        static if(is(T == class))
        {
            if(value is null)
            {
                return JSONValue(null);
            }
        }

        static foreach(member; T.tupleof)
        {{
            /**/
        }}

        return toReturn;
    }
    else
    { /**/ }
}
                        </code></pre>
                    </p>
                    <p>
                        Now if we were to pass a null class instance to the <code>serialise</code> function
                        it would output a <code>null</code> in JSON.
                    </p>
                    <p>
                        For our <code>deserialise</code> function it's a very similar process - check if
                        the given JSON value is null, and if it is then return null:

                        <pre><code>
T deserialise(T)(JSONValue json)
{
    static if(is(T == enum))
    { /* omitted for brevity */ }
    /**/
    else static if(is(T == struct) || is(T == class)) // Remember to check for a class here as well.
    {
        static if(is(T == class))
        {
            if(json.type == JSONType.null_)
                return null;

            T toReturn = new T();
        }
        else
        {
            T toReturn;
        }

        /**/

        return toReturn;
    }
    else
    { /**/ }
}
                        </code></pre>
                    </p>
                    <p>
                        Very simple, very easy to handle, unlike the can of worms we're about to open regarding
                        construction of a class.
                    </p>
                    <p>
                        But before we fall into despair over constructing classes, here's a quick test of the null
                        handling (change <code>Person</code> to a class):

                        <pre><code>
// <a href="https://godbolt.org/z/Q8pU7v">https://godbolt.org/z/Q8pU7v</a>
void main()
{
    import std.stdio : writeln;

    Person p = null;
    auto json = p.serialise();

    writeln(json);                      // null
    writeln(json.deserialise!Person()); // null
}
                        </code></pre>
                    </p>

                    <h3>Handling 'classes may not have a reliable way to construct them' with __traits(compiles)</h3>
                    <p>
                        Currently, we use the code <code>new T()</code> to construct a new instance of a class.
                        This will only work if the class has either no constructors, or a default constructor.
                    </p>
                    <p>
                        Again, realistically, classes are very likely to have parameterised constructors and will
                        likely not support having a default constructor.
                    </p>
                    <p>
                        Just as a note, this only applies to deserialisation, as serialising does not require
                        the construction of objects (well, unless you want it to).
                    </p>
                    <p>
                        There are many ways you may want to handle this, such as using
                        <a href="">std.traits.Parameters</a>
                        to check and recognise constructors with certain parameter patterns, having
                        a pre-defined list of constructor parameters that you support, or just
                        not allowing classes that do not contain a default constructor.
                    </p>
                    <p>
                        In our case we're going to disallow the use of classes that do not contain a default
                        constructor. Fret not though, as we will be exploring one potential workaround soon.
                    </p>
                    <p>
                        But for now we're going to be creating ourselves a helper template called <code>HasDefaultCtor</code>,
                        and using that in our <code>deserialise</code> function if the check returns <code>false</code>.

                    </p>
                    <p>
                        One way we can do this is to check if the exact code of <code>new T()</code> can compile,
                        which can be achieved via another magical function of <code>__traits()</code> called
                        <a href="https://dlang.org/spec/traits.html#compiles">__traits(compiles)</a>.
                    </p>
                    <p>
                        By passing in some code as a parameter, the compiler will determine if the code will
                        compile or not, and return a <code>bool</code> as the result.
                    </p>
                    <p>
                        Please note that there is a certain annoyance to <code>__traits(compiles)</code> when the code
                        you're checking contains a template function, but that is beyond this quick explanation of it.
                    </p>
                    <p>
                        Anyway, by telling the compiler to check if <code>new T()</code> works for a given type,
                        we can effectively check if the type has a default constructor, then from there
                        we can use a <code>static assert</code> to let us display a message to the user:

                        <pre><code>
enum HasDefaultCtor(T) = __traits(compiles, new T());

T deserialise(T)(JSONValue json)
{
    static if(is(T == enum))
    { /* omitted for brevity */ }
    /**/
    else static if(is(T == struct) || is(T == class))
    {
        static if(is(T == class))
        {
            static assert(HasDefaultCtor!T, "The class `" ~ T.stringof ~ "` requires a default constructor.");

            /**/
        }
        else
        {
            /**/
        }

        /**/

        return toReturn;
    }
    else
    { /**/ }
}
                        </code></pre>
                    </p>
                    <p>
                        Here is an example of the error message:

                        <pre><code>
// <a href="https://godbolt.org/z/NSwveB">https://godbolt.org/z/NSwveB</a>

class NoDefaultCtor
{
    this(string str){}
}

void main()
{
    deserialise!NoDefaultCtor(JSONValue());

    // .\temp.d(27): Error: static assert:  "The class `NoDefaultCtor` requires a default constructor."
    // .\temp.d(10):        instantiated from here: `deserialise!(NoDefaultCtor)`
}
                        </code></pre>
                    </p>
                    <p>
                        This isn't overly ideal for many reasons, but thankfully as we explore the workaround,
                        we'll implement something that handles this issue to a somewhat reasonable degree.
                    </p>

                    <h3>Workaround for the constructor issue, and the fact classes tend to not expose variables directly</h3>
                    <p>
                        I'll be brief. I've already gone over the constructor issue; and
                        because classes usually don't expose variables directly, our current behaviour won't work for most
                        of them.
                    </p>
                    <p>
                        Regarding the latter issue, there are several ways to handle the issue ranging from directly
                        inspecting the names of functions for keywords (e.g. starting with "get" or "set"), looking for
                        getters/setters that use the <code>@@property</code> attribute, and any other ways suitable
                        for your use cases.
                    </p>
                    <p>
                        The solution I will be going for is to add support for classes and structs to have a static
                        <code>deserialise</code> function. This will provide a workaround for the constructor issue, as this
                        is essentially just a special constructor, and will also outsource the task of handling deserialisation
                        to the class itself, which technically handles the issue of classes not generally exposing variables.
                    </p>
                    <p>
                        A downside of course is that there's more code to be written for classes to support
                        deserialisation, and therefore more technical debt over the long term.
                    </p>
                    <p>
                        While you could also just specifically check for a constructor that takes a <code>JSONValue</code>,
                        I prefer to create specific functions for things like this as I don't like
                        that it'll limit classes from providing a <code>this(JSONValue)</code> constructor for other
                        purposes.
                    </p>
                    <p>
                        The first thing we're going to do is make another helper template (similar to <code>HasDefaultCtor</code>)
                        that will check for the special <code>deserialise</code> function.
                    </p>
                    <p>
                        This template needs to check for:
                    </p>
                    <ul>
                        <li>A static function called <code>deserialise</code>.</li>
                        <li>The function's return value is the same/compatible type as the class.</li>
                        <li>The function takes a <code>JSONValue</code> as the first parameter.</li>
                    </ul>
                    <p>
                        There are a few ways to do this. One of these ways is to use <code>__traits(compiles)</code>
                        again:

                        <pre><code>
enum HasStaticDeserialiseFunc(T) = __traits(compiles, { T obj = T.deserialise(JSONValue()); });    
                        </code></pre>
                    </p>
                    <p>
                        Notice that the code we're checking is now inside brackets, since we're doing more
                        than a basic function call.
                    </p>
                    <p>
                        We're using <code>T.deserialise</code> to specifically check for a static function
                        (or anything that has the same syntax as a static function); we assign the return value
                        to a <code>T obj</code> to check that the return value is compatible with whatever <code>T</code> is;
                        then finally we also check that a <code>JSONValue</code> can be passed as the first parameter.
                    </p>
                    <p>
                        Next, in the <code>deserialise</code> function, we want to update the <code>static assert</code>
                        that requires classes to have a default constructor to check if the class has either
                        a default constructor, or a static deserialise function.
                    </p>
                    <p>
                        We also need to hide the <code>T toReturn = new T()</code> line behind
                        the <code>HasDefaultCtor</code> check:

                        <pre><code>
enum HasStaticDeserialiseFunc(T) = __traits(compiles, { T obj = T.deserialise(JSONValue()); });    

T deserialise(T)(JSONValue json)
{
    static if(is(T == enum))
    { /* omitted for brevity */ }
    /**/
    else static if(is(T == struct) || is(T == class))
    {
        static if(is(T == class))
        {
            static assert(HasDefaultCtor!T || HasStaticDeserialiseFunc!T, 
                "The class `" ~ T.stringof ~ "` requires a default constructor or a function matching "
               ~"`static " ~ T.stringof ~ " deserialise(JSONValue)`"
            ); 
            // e.g. "The class Person requires a default constructor or a function matching `static Person deserialise(JSONValue)`"

            /**/

            static if(HasDefaultCtor!T)
            {
                T toReturn = new T();
            }
        }
        /**/

        return toReturn;
    }
    else
    { /**/ }
}
                        </code></pre>
                    </p>
                    <p>
                        Now, if the class has a static deserialise function then we want to use that function
                        for deserialisation instead of our other logic. We still want to handle null JSONValues,
                        and we want to disable our other logic as we won't need it, among another issue of having
                        code exist beyond a <code>return</code> statement.
                    </p>
                    <p>
                        To do this, we just need to employ <code>static if</code> tactically:

                        <pre><code>
enum HasStaticDeserialiseFunc(T) = __traits(compiles, { T obj = T.deserialise(JSONValue()); });    

T deserialise(T)(JSONValue json)
{
    static if(is(T == enum))
    { /* omitted for brevity */ }
    /**/
    else static if(is(T == struct) || is(T == class))
    {
        static if(is(T == class))
        { /* null is still handled here */ }
        else
        { /**/ }
        
        static if(HasStaticDeserialiseFunc!T)
        {
            return T.deserialise(json);
        }
        else // If we don't disable this other code, then we'll get a "statement not reachable" error.
        {
            static foreach(/**/)
            {{
                /**/
            }}
            return toReturn;
        }
    }
    else
    { /**/ }
}
                        </code></pre>
                    </p>
                    <p>
                        To finish off, let's give it a test:

                        <pre><code>
// <a href="https://godbolt.org/z/Xbann8">https://godbolt.org/z/Xbann8</a>

class Person
{
    private
    {
        string name;
        int age;
        PersonType type;
    }

    // No default ctor.
    this(string name, int age, PersonType type)
    {
        this.name = name;
        this.age = age;
        this.type = type;
    }

    static Person deserialise(JSONValue value)
    {
        // Classes having to implement this logic themselves is a neccessary burden if you
        // were to go this route... or is it *wink* (this is a topic for a future post)
        return new Person(
            value["name"].deserialise!string(),
            value["age"].deserialise!int(),
            value["type"].deserialise!PersonType()
        );
    }

    // So that writeln can show us something useful.
    override string toString()
    {
        import std.format : format;

        return format("Person(%s, %s, %s)", this.name, this.age, this.type);
    }
}

void main()
{
    import std.stdio : writeln;

    auto person = new Person("Bradley", 20, PersonType.Student);
    auto json = person.serialise();

    writeln(json); // {"age":20,"name":"Bradley","type":"Student"}

    person = json.deserialise!Person();
    writeln(person); // Person(Bradley, 20, Student)
}
                        </code></pre>
                    </p>

                    <h2>Conclusion</h2>
                    <p>
                        Our serialiser can now serialise enums by name, and has some dodgey support for serialising
                        classes, meaning it's starting to shape up to be at least <em>kind of</em> useable. Maybe.
                        If you're desperate.
                    </p>
                    <p>
                        The next thing we'll look into is to serialise arrays and associative arrays.
                    </p>                    
                    <p>
                        <a asp-action="Blog" asp-route-post="JsonSerialiser2">Previous post - Serialising structs</a>
                    </p>
                    <p>
                        <a href="#">Next Post - NOT RELEASED YET</a>
                    </p>

                    <h2>Excercises</h2>

                    <h3>Add support for classes and structs to provide their own serialise function</h3>
                    <p>
                        This might be something I end up doing in a future post, but for now this is a
                        good excercise to practice using <code>__traits(compiles)</code>.
                    </p>
                    <p>
                        Basically, allow classes and structs to provide a custom <code>serialise</code> function.
                    </p>
                    <p>
                        For the test case to work, the serialise function must match the signature of: <code>JSONValue serialise()</code>
                    </p>
                    <p>
                        And here's the test case:

                        <pre><code>
struct VerySimpleTest
{
    string lalafell;

    JSONValue serialise()
    {
        JSONValue json;

        json["lalafell"] = this.lalafell;
        json["hidden_secret"] = "Don't be a lalafell please.";

        return json;
    }
}

void main()
{
    auto json = serialise(VerySimpleTest("Zuzu"));
    assert(json["lalafell"].str == "Zuzu");
    assert(json["hidden_secret"].str == "Don't be a lalafell please.");
}
                        </code></pre>
                    </p>
                </article>
            </div>
        </div>
    </div>
</section>