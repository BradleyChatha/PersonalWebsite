
@{
    ViewData["Title"] = "Alternate function layout";
    ViewData["NavItem"] = "Blog";
}

<section class="bluer background">
    <div class="one column grid">
        <div class="row">
            <div class="center column">
                <article class="blog post">
                    <h1>Creating a simple JSON serialiser in D #1.1 - Alternate function layout</h1>
                    <p>
                        <em>
                            This post is an optional post. The content and knowledge used here aren't required for
                            future posts, and simply exists as an aside "FYI" style post.
                        </em>
                    </p>
                    <p>
                        <em>
                            This post is a follow up of the
                            <a asp-action="Blog" asp-route-post="JsonSerialiser1">first one</a>.
                        </em>
                    </p>
                    <p>
                        For convenience, here's an shortened version of the <code>deserialise</code>
                        function that was created in the first post of this series.

                        <pre><code>
T deserialise(T)(JSONValue json)
{
    static if(is(T == string))
    { /**/ }
    else static if(is(T == bool))
    { /**/ }
    else static if(isFloatingPoint!T)
    { /**/ }
    else static if(isSigned!T)
    { /**/ }
    else static if(isUnsigned!T)
    { /**/ }
    else
    {
        static assert(false, "Don't know how to deserialise type: " ~ T.stringof);
    }
}
                            </code></pre>
                    </p>
                    <p>
                        The kind of 'design' we're doing with this function, is to have a singular template function
                        (<code>deserialise</code>) that takes any type as its input, and then we do all
                        the compile time checks inside the function.
                    </p>
                    <p>
                        What if we could write this another way? First, we need to know about template constraints.
                    </p>

                    <h2>Template constraints</h2>
                    <p>
                        Imagine we want a template function that only takes, for example, longs and strings, and nothing else.
                    </p>
                    <p>
                        While we could go the route of nesting a bunch of <code>static ifs</code> inside the function's body,
                        followed by a <code>static assert</code> should all of these <code>ifs</code> fail, what if instead
                        we tell the compiler the <em>exact</em> conditions needed for it to even consider using the template function?
                    </p>
                    <p>
                        I feel an example will help clear things up:

                        <pre><code>
void someFunc(T)(T value)
if(is(T == string) || is(T == long))
{
    // Do stuff.
}
                        </code></pre>
                    </p>
                    <p>
                        So what's happening here is that we're creating a template function called <code>someFunc</code>
                        which takes a type parameter (T), and it does stuff, similar to the other template functions we've made so far.
                    </p>
                    <p>
                        However, take note that we can actually attach an <code>if</code> statement <em>directly to the function's signature</em>.
                        This is a constraint, which you can imagine as a <code>static if</code> that applies for the entire function as a whole.
                    </p>
                    <p>
                        This constraint's condition <strong>must</strong> pass if you want the compiler to make use of the function,
                        depending on what you pass to the template's parameters.
                    </p>
                    <p>
                        For example:

                        <pre><code>
// <a href="https://run.dlang.io/is/bYQUBq">https://run.dlang.io/is/bYQUBq</a>
void main()
{
    someFunc!long(200);              // Fine
    someFunc!string("Hello world!"); // Fine
    someFunc!bool(false);            // Error (see comment below)

    // The error given is:
    /*
    onlineapp.d(5): Error: template instance onlineapp.someFunc!bool does not match template declaration someFunc(T)(T value)
      with T = bool
      must satisfy one of the following constraints:
           is(T == string)
           is(T == long)
    */
}

void someFunc(T)(T value)
if(is(T == string) || is(T == long))
{
    import std.stdio : writeln;
    writeln(T.stringof);
}
                        </code></pre>
                    </p>

                    <h2>Using constraints to create template overloads</h2>
                    <p>
                        By using constraints, we can essentially create overloads for template functions.
                    </p>
                    <p>
                        Take these two functions for example:

                        <pre><code>
void someFunc(T)(T value)
if(is(T == string))
{
    // stuff with strings
}

void someFunc(T)(T value)
if(is(T == long))
{
    // stuff with longs
}
                        </code></pre>
                    </p>
                    <p>
                        They both have the same name, same template parameters, and same runtime parameters. Their
                        only differences are their constraints.
                    </p>
                    <p>
                        When calling a template function with overloads like this, the compiler will try to match
                        every single overload with the parameters that you pass to it (which includes testing the constraints).
                    </p>
                    <ul>
                        <li>If no overloads matches your parameters, the compile fails.</li>
                        <li>If more than one overload matches your parameters, the compile fails due to ambiguity.</li>
                        <li>If exactly one overload matches your parameters, that overload will be used.</li>
                        <li>(likely other stuff that's a bit more in-depth to explain)</li>
                    </ul>
                    <p>
                        This is on top of the normal overload rules D uses.
                    </p>
                    <p>
                        What this means is that instead of a singular <code>deserialise</code> function with a bunch
                        of <code>static ifs</code>, you could also/instead use seperate overloads for each type
                        of data you want to deserialise:

                        <pre><code>
// For strings
string deserialise(T)(JSONValue json)
if(is(T == string))
{ /*code here*/ }

// For floats and doubles
T deserialise(T)(JSONValue json)
if(isFloatingPoint!T)
{ /*code here*/ }

// Using both constraints, and static if chains
T deserialise(T)(JSONValue json)
if(isIntegral!T)
{
    static if(isSigned!T)
    { /**/ }
    else static if(isUnsigned!T)
    { /**/ }
}

// etc.
                        </code></pre>
                    </p>

                    <h2>Conclusion</h2>
                    <p>
                        There are pros and cons to both designs, and there are of course more complicated ways/features
                        that can be used to design your code around templates that need to discriminate by things like types.
                    </p>
                    <p>
                        However, the main point of this one-off post was just to show and explain a different way
                        of doing things, so that it doesn't seem like a nested web of <code>static ifs</code> is the only
                        way to handle something like this.
                    </p>
                    <p>
                        <a asp-action="Blog" asp-route-post="JsonSerialiser1">Previous post - Serialising basic types</a>
                    </p>
                    <p>
                        <a asp-action="Blog" asp-route-post="JsonSerialiser2">Next Post - Serialising structs</a>
                    </p>

                </article>
            </div>
        </div>
    </div>
</section>